1.	林彬使用了消息队列处理消息；使用C#语言实现GUI客户端，用户体验较好；程序中对功能模块（比如IP地址、消息、TCP通信）进行了适当面向对象封装，逻辑清晰易懂
2.	温扬威支持变长protobuf消息的编解码,并对服务端和客户端业务对象进行了适当封装，异常处理考虑比较完善
3.	林严使用了winform实现服务端和客户端，用户体检较好
4.	詹子棋同学使用了Protobuf封装数据，程序启动的时候调用了GOOGLE_PROTOBUF_VERIFY_VERSION验证版本，程序最后调用ShutdownProtobufLibrary清理资源
5.	张凯使用了U3D实现客户端，并支持中英文输入。

问题方面：
1.	功能实现不够完整：直接拷贝复制了视频教程中的实现，只实现了1个客户端和服务器之间1对1的通信，只能依次轮流发送消息，没有实现广播。
2.	资源未清理：服务端和客户端在socket调用发生异常的分支语句中没有调用WSACleanup
3.	Protobuf的使用还比较初级：部分同学使用了Protobuf封装消息，但是都只能解析某个固定大小（比如1024字节）以下的消息，而且只能解析一种消息类型
4.	缺少面向对象设计：没有将功能（比如通信、线程）单独封装成对应的类，采用旧的C语言编码风格，直接写全局的方法，或者基本上就只有一个main方法。
5.	代码工程组织混乱：服务端和客户端功能混合在一个工程，没有分开。
6.	服务端和客户端发生异常，程序退出时忘记调用WSACleanup。
7.	没有提交.proto文件，.proto文件也属于工程的一部分，也需要提交。